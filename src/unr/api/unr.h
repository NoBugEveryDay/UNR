/**
 * @file unr.h
 * @author Guangnan Feng (nobugday@gamil.com)
 * @brief This file defines Unified Notifiable RMA (UNR) Library API.
 * @version 1.0
 * @date 2023-12-28
 *
 * @copyright Copyright (c) 2023
 *
 */

#pragma once

#include <uru_status.h>
#include <mpi.h>
#include <stdlib.h>
#include <stdint.h>

/**
 * @defgroup UNR_API UNR: Unified Notifiable RMA (UNR) Library for HPC  API
 * @brief   This section contains UNR API.
 */

/**
 * @ingroup UNR_API
 * @brief   Abbreviation for "UNR Memory Handle".
 *          It is generated by \ref unr_mem_reg.
 *          Usually, we can only generate only limit number of memory handles because of the limited resources in network device.
 */
typedef void* unr_mem_h;

/**
 * @ingroup UNR_API
 * @brief   Abbreviation for "UNR (RDMA WRITE) Block Handle".
 *          It is generated by \ref unr_blk_reg.
 *          User have to use it to perform RDMA send and receive.
 */
typedef struct {
    uint8_t space[40];
} unr_blk_h;

/**
 * @ingroup UNR_API
 * @brief The MPI datatype of \ref unr_blk_h
 */
extern MPI_Datatype MPI_UNR_BLK_H;

/**
 * @ingroup UNR_API
 * @brief   Abbreviation for "UNR Signal Handle".
 *          It is used for check whether a/some RDMA op(s) is/are finished.
 */
typedef struct {
    uint8_t space[12];
} unr_sig_h;

/**
 * @ingroup UNR_API
 * @brief The MPI datatype of \ref unr_sig_h
 */
extern MPI_Datatype MPI_UNR_SIG_H;

/**
 * @ingroup UNR_API
 * @brief   Abbreviation for "UNR Signal Pool Handle".
 *          A signal pool contains a set of signals.
 *          It is used for check whether any signal is triggered in this pool.
 */
typedef void* unr_sig_pool_h;

/**
 * @ingroup UNR_API
 * @brief   Abbreviation for "UNR Plan Handle".
 *          Multiple RDMA writes can be registered as a plan.
 *          Start RDMA writes with a plan can save time for preparing RDMA writes.
 */
typedef void* unr_plan_h;

/**
 * @ingroup UNR_API
 * @brief Initialize UNR. It should be called after MPI_Init.
 */
uru_status_t unr_init();

/**
 * @ingroup UNR_API
 * @brief Finalize UNR. It should be called before MPI_Finalize.
 */
uru_status_t unr_finalize();

/**
 * @ingroup UNR_API
 * @brief Register a memory region that can be used by RDMA send and receive.
 * @param[in]   addr    The address of the memory region.
 * @param[in]   size    The size of the memory region.
 * @param[out]  mem_h   The handle of the memory region.
 *                      The local process use it to check whether the data is received.
 */
uru_status_t unr_mem_reg(void* addr, size_t size, unr_mem_h* mem_h);

/**
 * @brief Synchronize the memory region with all other processes.
 */
uru_status_t unr_mem_reg_sync();

/**
 * @ingroup UNR_API
 * @brief Register a block in a memory region. The unit of RDMA is block.
 * @param[in] mem_h         An registered memory region handle.
 * @param[in] offset        The offset of the block in the memory region.
 * @param[in] size          The size of the block.
 * @param[in] send_sig_h    The signal will be triggered after this block is sent on the local process.
 *                          This signal have to belong to the same block as the block.
 *                          If no local signal is needed to be triggered or local signal is assigned when sending, it can be \ref UNR_NO_SIGNAL.
 * @param[in] recv_sig_h    The signal will be triggered after this block is received on the local process.
 *                          This signal have to belong to the same block as the block.
 *                          If no remote signal is needed to be triggered or remote signal is assigned when sending, it can be \ref UNR_NO_SIGNAL.
 * @param[out] blk_h        The handle of the block.
 */
uru_status_t unr_blk_reg(unr_mem_h mem_h, size_t offset, size_t size, unr_sig_h send_sig_h, unr_sig_h recv_sig_h, unr_blk_h* blk_h);

/**
 * @brief If it is used in \ref unr_blk_reg, it indicates that no signal is needed to be triggered or the signal is assigned when sending.
 *        If it is used in unr_blk_*_send_*, it indicates that no signal is needed to be triggered or the signal is assigned when block registering.
 */
extern unr_sig_h UNR_NO_SIGNAL;

/**
 * @ingroup UNR_API
 * @brief Create a signal. A signal is used to check whether a/some RDMA op(s) is/are finished.
 * @param[out] sig_h        The handle of the signal.
 * @param[in] num_event     The signal will be triggered only after `num_event` events.
 */
uru_status_t unr_sig_create(unr_sig_h* sig_h, uint64_t num_event);

/**
 * @ingroup UNR_API
 * @brief Used in \ref unr_sig_create to indicate the signal is ONLY checked by \ref unr_sig_check.
 */
#define UNR_SIG_TYPE_CHECK 1

/**
 * @ingroup UNR_API
 * @brief Used in \ref unr_sig_create to indicate the signal is ONLY detected by \ref unr_sig_pool_detect.
 */
#define UNR_SIG_TYPE_DETECT 2

/**
 * @ingroup UNR_API
 * @brief Reset the signal. A signal can ONLY be triggered after reset.
 * @param[in] sig_h The handle of the signal.
 */
uru_status_t unr_sig_reset(unr_sig_h sig_h);

/**
 * @ingroup UNR_API
 * @brief Check whether the signal is triggered.
 * @param[in] sig_h The handle of the signal.
 */
uru_status_t unr_sig_check(unr_sig_h sig_h);

/**
 * @ingroup UNR_API
 * @brief Wait until the signal is triggered.
 * @param[in] sig_h The handle of the signal.
 */
uru_status_t unr_sig_wait(unr_sig_h sig_h, const char *file, int line, const char *func);

#define unr_sig_wait(sig_h) unr_sig_wait(sig_h, __FILE__, __LINE__, __func__)

/**
 * @ingroup UNR_API
 * @brief Create a signal pool that can detect whether any signal is triggered in this pool.
 * @param[in] sig_h The handle of the signal.
 */
uru_status_t unr_sig_pool_create(unr_sig_pool_h* sig_pool_h, int32_t num_sigs, unr_sig_h* sig_h_arr);

/**
 * @ingroup UNR_API
 * @brief Detect whether any signal is triggered in this pool.
 * @param[in] sig_pool_h    The handle of the signal pool.
 * @param[out] sig_id       The id of the triggered signal.
 */
uru_status_t unr_sig_pool_detect(unr_sig_pool_h sig_pool_h, int32_t* sig_id);

/**
 * @ingroup UNR_API
 * @brief   Start an RDMA Write from local memory block to remote memory block.
 *          The entire local memory block will be sent.
 * @attention The size of the local memory block and the remote memory block must be the same.
 * @param[in] loc_blk_h It has to be an local memory block handle.
 * @param[in] loc_sig_h The signal will be triggered after the sender finishes sending data.
 *                      If no local signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] rmt_blk_h It has to be an remote memory block handle.
 * @param[in] rmt_sig_h The signal will be triggered after the receiver finishes receiving data.
 *                      If no remote signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] dma_type  The type of RDMA transfer. It should be URU_TRANSFER_TYPE_DMA_PUT or URU_TRANSFER_TYPE_DMA_GET.
 */
uru_status_t unr_blk_rdma_start(
    unr_blk_h loc_blk_h, unr_sig_h loc_sig_h,
    unr_blk_h rmt_blk_h, unr_sig_h rmt_sig_h, uru_transfer_t dma_type);

/**
 * @brief Register a RDMA write plan including an RDMA Write from local memory block to remote memory block.
 * @param[in] loc_blk_h It has to be an local memory block handle.
 * @param[in] loc_sig_h The signal will be triggered after the sender finishes sending data.
 *                      If no local signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] rmt_blk_h It has to be an remote memory block handle.
 * @param[in] rmt_sig_h The signal will be triggered after the receiver finishes receiving data.
 *                      If no remote signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] dma_type  The type of RDMA transfer. It should be URU_TRANSFER_TYPE_DMA_PUT or URU_TRANSFER_TYPE_DMA_GET.
 * @param[in] plan_h    The handle of the registered plan.
 */
uru_status_t unr_blk_rdma_plan(
    unr_blk_h loc_blk_h, unr_sig_h loc_sig_h,
    unr_blk_h rmt_blk_h, unr_sig_h rmt_sig_h, uru_transfer_t dma_type,
    unr_plan_h* plan_h);

/**
 * @ingroup UNR_API
 * @brief Start an RDMA Write from part of local memory block to part of remote memory block.
 * @param[in] loc_blk_h     It has to be an local memory block handle.
 * @param[in] loc_sig_h     The signal will be triggered after the sender finishes sending data.
 *                          If no local signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] loc_offset    The start address offset of the sending data region corresponding to the local memory block.
 * @param[in] size          The size of data to be sent
 * @param[in] rmt_blk_h     It has to be an remote memory block handle.
 * @param[in] rmt_sig_h     The signal will be triggered after the receiver finishes receiving data.
 *                          If no remote signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] rmt_offset    The start address offset of the receiving data region corresponding to the remote memory block.
 * @param[in] dma_type  The type of RDMA transfer. It should be URU_TRANSFER_TYPE_DMA_PUT or URU_TRANSFER_TYPE_DMA_GET.
 */
uru_status_t unr_blk_part_rdma_start(
    unr_blk_h loc_blk_h, unr_sig_h loc_sig_h, size_t loc_offset, size_t size,
    unr_blk_h rmt_blk_h, unr_sig_h rmt_sig_h, size_t rmt_offset, uru_transfer_t dma_type);

/**
 * @brief Register a RDMA write plan including an RDMA Write from local memory block to remote memory block.
 * @param[in] loc_blk_h     It has to be an local memory block handle.
 * @param[in] loc_sig_h     The signal will be triggered after the sender finishes sending data.
 *                          If no local signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] loc_offset    The start address offset of the sending data region corresponding to the local memory block.
 * @param[in] size          The size of data to be sent
 * @param[in] rmt_blk_h     It has to be an remote memory block handle.
 * @param[in] rmt_sig_h     The signal will be triggered after the receiver finishes receiving data.
 *                          If no remote signal is needed to be triggered or the signal is assigned in \ref unr_blk_reg, it can be NULL.
 * @param[in] rmt_offset    The start address offset of the receiving data region corresponding to the remote memory block.
 * @param[in] dma_type  The type of RDMA transfer. It should be URU_TRANSFER_TYPE_DMA_PUT or URU_TRANSFER_TYPE_DMA_GET.
 * @param[in] plan_h        The handle of the registered plan.
 */
uru_status_t unr_blk_part_rdma_plan(
    unr_blk_h loc_blk_h, unr_sig_h loc_sig_h, size_t loc_offset, size_t size,
    unr_blk_h rmt_blk_h, unr_sig_h rmt_sig_h, size_t rmt_offset, uru_transfer_t dma_type,
    unr_plan_h* plan_h);

/**
 * @ingroup UNR_API
 * @brief Start some RDMA Writes from local memory blocks to corresponding remote memory blocks.
 *        The entire local memory blocks will be sent.
 *        The parameters are the same as \ref unr_blk_rdma_start except that they are arrays.
 * @attention The size of the i-th local memory blocks and the i-th remote memory blocks must be the same.
 * @param[in] num_sends The number of RDMA Writes.
 * @param[in] loc_blk_h_arr The array of local memory block handles.
 * @param[in] loc_sig_h_arr The array of local signal handles.
 * @param[in] rmt_blk_h_arr The array of remote memory block handles.
 * @param[in] rmt_sig_h_arr The array of remote signal handles.
 * @param[in] dma_type_arr  The array of RDMA transfer type.
 *                          It could be URU_TRANSFER_TYPE_DMA_PUT_ALL, URU_TRANSFER_TYPE_DMA_GET_ALL,
 *                          or an array of URU_TRANSFER_TYPE_DMA_PUT and URU_TRANSFER_TYPE_DMA_GET.
 */
uru_status_t unr_blk_rdma_batch_start(
    size_t num_sends,
    unr_blk_h* loc_blk_h_arr, unr_sig_h* loc_sig_h_arr,
    unr_blk_h* rmt_blk_h_arr, unr_sig_h* rmt_sig_h_arr, uru_transfer_t* dma_type_arr);

/**
 * @brief Register a RDMA write plan including multiple RDMA Writes from local memory blocks to corresponding remote memory blocks.
 * @param[in] num_sends     The number of RDMA Writes.
 * @param[in] loc_blk_h_arr The array of local memory block handles.
 * @param[in] loc_sig_h_arr The array of local signal handles.
 * @param[in] rmt_blk_h_arr The array of remote memory block handles.
 * @param[in] rmt_sig_h_arr The array of remote signal handles.
 * @param[in] dma_type_arr  The array of RDMA transfer type.
 *                          It could be URU_TRANSFER_TYPE_DMA_PUT_ALL, URU_TRANSFER_TYPE_DMA_GET_ALL,
 *                          or an array of URU_TRANSFER_TYPE_DMA_PUT and URU_TRANSFER_TYPE_DMA_GET.
 * @param[in] plan_h        The handle of the registered plan.
 */
uru_status_t unr_blk_rdma_batch_plan(
    size_t num_sends,
    unr_blk_h* loc_blk_h_arr, unr_sig_h* loc_sig_h_arr,
    unr_blk_h* rmt_blk_h_arr, unr_sig_h* rmt_sig_h_arr, uru_transfer_t* dma_type_arr,
    unr_plan_h* plan_h);

/**
 * @ingroup UNR_API
 * @brief Start some RDMA Writes from part of local memory blocks to corresponding part of remote memory blocks.
 *        The parameters are the same as \ref unr_blk_part_rdma_start except that they are arrays.
 * @param[in] num_sends     The number of RDMA Writes.
 * @param[in] loc_blk_h_arr The array of local memory block handles.
 * @param[in] loc_sig_h_arr The array of local signal handles.
 * @param[in] loc_offset    The array of offsets of the local memory blocks.
 * @param[in] size          The array of sizes of data to be sent.
 * @param[in] rmt_blk_h_arr The array of remote memory block handles.
 * @param[in] rmt_sig_h_arr The array of remote signal handles.
 * @param[in] rmt_offset    The array of offsets of the remote memory blocks.
 * @param[in] dma_type_arr  The array of RDMA transfer type.
 *                          It could be URU_TRANSFER_TYPE_DMA_PUT_ALL, URU_TRANSFER_TYPE_DMA_GET_ALL,
 *                          or an array of URU_TRANSFER_TYPE_DMA_PUT and URU_TRANSFER_TYPE_DMA_GET.
 */
uru_status_t unr_blk_part_rdma_batch_start(
    size_t num_sends,
    unr_blk_h* loc_blk_h_arr, unr_sig_h* loc_sig_h_arr, size_t* loc_offset, size_t* size,
    unr_blk_h* rmt_blk_h_arr, unr_sig_h* rmt_sig_h_arr, size_t* rmt_offset, uru_transfer_t* dma_type_arr);

/**
 * @ingroup UNR_API
 * @brief Register a RDMA write plan including multiple RDMA Writes from part of local memory blocks to corresponding part of remote memory blocks.
 *        The parameters are the same as \ref unr_blk_part_rdma_start except that they are arrays.
 * @param[in] num_sends     The number of RDMA Writes.
 * @param[in] loc_blk_h_arr The array of local memory block handles.
 * @param[in] loc_sig_h_arr The array of local signal handles.
 * @param[in] loc_offset    The array of offsets of the local memory blocks.
 * @param[in] size          The array of sizes of data to be sent.
 * @param[in] rmt_blk_h_arr The array of remote memory block handles.
 * @param[in] rmt_sig_h_arr The array of remote signal handles.
 * @param[in] rmt_offset    The array of offsets of the remote memory blocks.
 * @param[in] dma_type_arr  The array of RDMA transfer type.
 *                          It could be URU_TRANSFER_TYPE_DMA_PUT_ALL, URU_TRANSFER_TYPE_DMA_GET_ALL,
 *                          or an array of URU_TRANSFER_TYPE_DMA_PUT and URU_TRANSFER_TYPE_DMA_GET.
 * @param[out] plan_h       The handle of the registered plan.
 */
uru_status_t unr_blk_part_rdma_batch_plan(
    size_t num_sends,
    unr_blk_h* loc_blk_h_arr, unr_sig_h* loc_sig_h_arr, size_t* loc_offset, size_t* size,
    unr_blk_h* rmt_blk_h_arr, unr_sig_h* rmt_sig_h_arr, size_t* rmt_offset, uru_transfer_t* dma_type_arr,
    unr_plan_h* plan_h);

uru_status_t unr_plan_start(unr_plan_h plan_h);

uru_status_t unr_plan_destroy(unr_plan_h plan_h);